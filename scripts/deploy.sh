#!/bin/bash

# ===================================================================================
# MAJESTIC DEPLOYMENT SCRIPT
#
# This script automates the following steps:
#   1. Sets up environment variables and colors for output.
#   2. Validates that required tools (aws, docker, jq) are installed.
#   3. Retrieves necessary AWS resource names from Terraform outputs.
#   4. Logs in to Amazon ECR.
#   5. Builds the Docker image for the application.
#   6. Tags the Docker image for the ECR repository.
#   7. Pushes the Docker image to ECR.
#   8. Forces a new deployment of the ECS service to pull the new image.
#   9. Waits for the new deployment to become stable.
#
# Usage:
#   ./scripts/deploy.sh [image_tag]
#
#   - [image_tag]: (Optional) A specific tag for the Docker image.
#                  Defaults to "latest".
#
# Prerequisites:
#   - AWS CLI installed and configured with necessary permissions.
#   - Docker installed and running.
#   - jq installed.
#   - A 'terraform.output.json' file in the 'terraform/' directory,
#     generated by running 'terraform output -json > terraform.output.json'
#     in the terraform directory.
# ===================================================================================

set -e # Exit immediately if a command exits with a non-zero status.

# --- Configuration ---
# Colors for better readability
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# --- Helper Functions ---
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
    exit 1
}

# --- Main Script ---
log_info "Starting Majestic deployment process..."

# 1. Check for required tools
for cmd in aws docker jq; do
    if ! command -v $cmd &> /dev/null; then
        log_error "$cmd is not installed. Please install it before running this script."
    fi
done
log_success "All required tools (aws, docker, jq) are installed."

# 2. Get AWS resource names from Terraform output
TF_OUTPUT_FILE="terraform/terraform.output.json"
if [ ! -f "$TF_OUTPUT_FILE" ]; then
    log_error "Terraform output file not found at '$TF_OUTPUT_FILE'. Please run 'terraform output -json > $TF_OUTPUT_FILE' in the 'terraform/' directory."
fi

AWS_REGION=$(jq -r '.aws_region.value' "$TF_OUTPUT_FILE")
ECR_REPOSITORY_URL=$(jq -r '.ecr_repository_url.value' "$TF_OUTPUT_FILE")
ECS_CLUSTER_NAME=$(jq -r '.ecs_cluster_name.value' "$TF_OUTPUT_FILE")
ECS_SERVICE_NAME=$(jq -r '.ecs_service_name.value' "$TF_OUTPUT_FILE")

if [ "$ECR_REPOSITORY_URL" == "null" ] || [ "$ECS_CLUSTER_NAME" == "null" ] || [ "$ECS_SERVICE_NAME" == "null" ]; then
    log_error "Could not read required values from '$TF_OUTPUT_FILE'. Make sure it contains ecr_repository_url, ecs_cluster_name, and ecs_service_name."
fi
log_success "Successfully loaded AWS resource details from Terraform outputs."
log_info "  - ECR Repository: $ECR_REPOSITORY_URL"
log_info "  - ECS Cluster:    $ECS_CLUSTER_NAME"
log_info "  - ECS Service:    $ECS_SERVICE_NAME"
log_info "  - AWS Region:     $AWS_REGION"

# 3. Set Image Tag
IMAGE_TAG=${1:-latest}
log_info "Using image tag: $IMAGE_TAG"

# 4. Authenticate Docker to Amazon ECR
log_info "Authenticating Docker to Amazon ECR..."
aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$ECR_REPOSITORY_URL"
log_success "ECR login successful."

# 5. Build the Docker image
log_info "Building Docker image: $ECR_REPOSITORY_URL:$IMAGE_TAG..."
docker build -t "$ECR_REPOSITORY_URL:$IMAGE_TAG" .
log_success "Docker image built successfully."

# 6. Push the Docker image to ECR
log_info "Pushing image to ECR..."
docker push "$ECR_REPOSITORY_URL:$IMAGE_TAG"
log_success "Image pushed successfully to ECR."

# 7. Update the ECS service to force a new deployment
log_info "Updating ECS service '$ECS_SERVICE_NAME' to start a new deployment..."
aws ecs update-service \
    --cluster "$ECS_CLUSTER_NAME" \
    --service "$ECS_SERVICE_NAME" \
    --force-new-deployment \
    --region "$AWS_REGION" > /dev/null
log_success "ECS service update initiated. A new deployment is rolling out."

# 8. Wait for the deployment to complete
log_info "Waiting for the new deployment to become stable... (This may take a few minutes)"
aws ecs wait services-stable \
    --cluster "$ECS_CLUSTER_NAME" \
    --services "$ECS_SERVICE_NAME" \
    --region "$AWS_REGION"
log_success "Deployment is stable. The new version is now running."

echo -e "\n${GREEN}========================================="
log_success "  Majestic Deployment Complete!"
echo -e "=========================================${NC}\n"
APPLICATION_URL=$(jq -r '.application_url.value' "$TF_OUTPUT_FILE")
if [ "$APPLICATION_URL" != "null" ]; then
    log_info "Your application should be available at: ${YELLOW}$APPLICATION_URL${NC}"
    log_info "Run the health-check script to verify: ./scripts/health-check.sh"
fi
echo ""